Объяснения • Lab3 
# 1. Функции и линкер
# Простой пример
```cpp
int func(int x);

int main()
{
    cout << func(5);
}
```
Возникнет ошибка компиляции из-за ошибки линкера - функция объявлена, но не определена.

После определения функции всё заработает:
```cpp
int func(int x) 
{
    return x+=x;   
}

int main()
{
    cout << func(5);
}
```

# Пример с 2 файлами
### Пункты **с 1 по 4**
Оба файла выдадут ошибку компиляции по причине из *Простого примера*, то есть ошибка линкера т.к. функция объявлена, но не определена.
### Пункты **с 5 по 6**
Функция `hello`, будучи определенной, не будет выбивать ошибку в компиляции, так как у линкера не возникнет ошибок.

Сам по себе `main.cpp` не был изменен, т.е. функция по прежнему не определена -> ошибка линкера = ошибка компиляции.
### Пункты **с 7 по 11**
```cpp
static int hello (int num);

int main()
{
    //cout << func(5);
    hello(5);
}
```
Компиляция прервана с последующей ошибкой:
> function 'hello' has internal linkage but is not defined

Проблема с линковкой не возникла - теперь из-за `static` она внутренне линкована, но ошибка вызвана тем, что **функция не определена (is not defined)**.

Следующий код ошибку не выдаст:
```cpp
static int hello (int num)
{
    return num;
};

int main()
{
    //cout << func(5);
    hello(5);
}
```
**Почему работает?** Потому что у линкера не возникает вопросов из-за `static` (internal linkage) и функция определена.

**Сколько копий тела функции `hello` скомипилируется?**
> Две разные статические функции могут быть определены в нескольких компиляционных единицах, и все они окажутся в исполняемом файле, и они будут обрабатываться независимо.

Исходя из этого определения и, учитывая, что в `f.cpp` и `main.cpp` объявлено и определено:
```cpp
static int hello (int num)
{
    return num;
};
```
То будут созданы 2 копии тела функции `hello`.

# 2. Stack, Heap, Static Memory
